# 2.3 Integer Arithmetic

Many beginning programmers are surprised to find that adding two positive numbers can yield a negative result, and that the comparison x\<y can yield a different result than the comparison x-y < 0. These properties are artifacts of the finite nature of computer arithmetic. Understanding the nuances of computer arithmetic can help programmers write more reliable code.

## 2.3.1 Unsigned Addition

Consider two nonnegative integers x and y, such that 0 ≤ x, y ≤ $$2^w$$-1. Each of these values can be represented by a w-bit unsigned number. If we compute their sum, however, we have a possible range 0 ≤ x + y ≤ $$2^{w+1}$$ − 2. Representing this sum could require w + 1 bits. For example, Figure 2.21 shows a plot of the function x + y when x and y have 4-bit representations. The arguments (shown on the horizontal axes) range from 0 to 15, but the sum ranges from 0 to 30. The shape of the function is a sloping plane (the function is linear in both dimensions). If we were to maintain the sum as a (w + 1)-bit number and add it to another value, we may require w + 2 bits, and so on. This continued “word size inflation” means we cannot place any bound on the word size required to fully represent the results of arithmetic operations. Some programming languages, such as **Lisp**, actually support arbitrary size arithmetic to allow integers of any size (within the memory limits of the computer, of course.) More commonly, programming languages support fixed-size arithmetic, and hence operations such as “addition” and “multiplication” differ from their counterpart operations over integers.

![Figure 2.21 Integer addition. With a 4-bit word size, the sum could require 5 bits](<../../.gitbook/assets/image (25).png>)

Let us define the operation $$+^u_w$$ for arguments x and y, where 0 ≤ x, y ≤ $$2^w$$-1, as the result of truncating the integer sum x + y to be w bits long and then viewing the result as an unsigned number. This can be characterized as a form of modular arithmetic, computing the sum modulo $$2^w$$ by simply discarding any bits with weight greater than $$2^{w−1}$$ in the bit-level representation of x + y. For example, consider a 4-bit number representation with x = 9 and y = 12, having bit representations \[1001] and \[1100], respectively. Their sum is 21, having a 5-bit representation \[10101]. But if we discard the high-order bit, we get \[0101], that is, decimal value 5. This matches the value 21 mod 16 = 5.

We can characterize operation $$+^u_w$$ as follows:

![](<../../.gitbook/assets/image (29).png>)

The two cases of Equation 2.11 are illustrated in Figure 2.22, showing the sum x + y on the left mapping to the unsigned w-bit sum x $$+^u_w$$ y on the right. The normal case preserves the value of x + y, while the overflow case has the effect of decrementing this sum by $$2^w$$.

![Figure 2.22 Relation between integer addition and unsigned addition. When x + y is greater than 2w − 1, the sum overflows.](<../../.gitbook/assets/image (24).png>)

<mark style="color:blue;">**DERIVATION**</mark>**: Unsigned addition**

In general, we can see that if x + y < 2^w, the leading bit in the (w + 1)-bit representation of the sum will equal 0, and hence discarding it will not change the numeric value. On the other hand, if 2^w ≤ x + y < 2^{w+1}, the leading bit in the (w + 1)-bit representation of the sum will equal 1, and hence discarding it is equivalent to subtracting 2^w from the sum.

An arithmetic operation is said to **overflow** when the full integer result cannot fit within the word size limits of the data type. As Equation 2.11 indicates, overflow occurs when the two operands sum to 2^w or more. Figure 2.23 shows a plot of the unsigned addition function for word size w = 4. The sum is computed modulo 2^4 = 16. When x + y < 16, there is no overflow, and x $$+^u_4$$ y is simply x + y. This is shown as the region forming a sloping plane labeled “Normal.” When x + y ≥ 16, the addition overflows, having the effect of decrementing the sum by 16. This is shown as the region forming a sloping plane labeled “Overflow.”

![Figure 2.23
Unsigned addition. With a 4-bit word size, addition is performed modulo 16.](<../../.gitbook/assets/image (22).png>)

When executing C programs, overflows are not signaled as errors. At times, however, we might wish to determine whether or not overflow has occurred.

![](<../../.gitbook/assets/image (10).png>)

As an illustration, in our earlier example, we saw that 9 $$+^u_4$$ 12 = 5. We can see that overflow occurred, since 5 < 9.

<mark style="color:blue;">**DERIVATION**</mark>**: Detecting overflow of unsigned addition**

Observe that x + y ≥ x, and hence if s did not overflow, we will surely have s ≥ x. On the other hand, if s did overflow, we have s = x + y − 2^w. Given that y < 2^w, we have y − 2^w < 0, and hence s = x + (y − 2^w) < x.

Modular addition forms a mathematical structure known as an **abelian group**, named after the Norwegian mathematician Niels Henrik Abel (1802–1829). That is, it is **commutative** (that’s where the “abelian” part comes in) and **associative**; it has an **identity element** 0, and every element has an **additive inverse**. Let us consider the set of w-bit unsigned numbers with addition operation $$+^u_ w$$. For every value x, there must be some value $$-^u_wx$$ such that $$-^u_wx$$ $$+^u_wx$$ = 0. This additive inverse operation can be characterized as follows:

![](<../../.gitbook/assets/image (21).png>)

This result can readily be derived by case analysis:

<mark style="color:blue;">**DERIVATION**</mark>**: Unsigned negation**

When x = 0, the additive inverse is clearly 0. For x > 0, consider the value 2^w − x. Observe that this number is in the range 0 < 2^w − x < 2^w. We can also see that (x + 2^w − x) mod 2w = 2w mod 2w = 0. Hence it is the inverse of x under $$+^u_w$$.

{% tabs %}
{% tab title="Practice Problem 2.27" %}
Write a function with the following prototype:

```c
/* Determine whether arguments can be added without overflow */
int uadd_ok(unsigned x, unsigned y);
```

This function should return 1 if arguments x and y can be added without causing overflow.
{% endtab %}

{% tab title="Practice Problem 2.28" %}
We can represent a bit pattern of length w = 4 with a single hex digit. For an unsigned interpretation of these digits, use Equation 2.12 to fill in the following table giving the values and the bit representations (in hex) of the unsigned additive inverses of the digits shown.

![](<../../.gitbook/assets/image (20).png>)
{% endtab %}
{% endtabs %}

{% tabs %}
{% tab title="Solution 2.27" %}
```c
int uadd_ok(unsigned x, unsigned y) {
    return (x+y>=x) && (x+y>=y);
}
```
{% endtab %}

{% tab title="Solution 2.28" %}
1        15        0xE

4       12        0xC

7        9         0x9

10      6         0x6

14      2         0x2
{% endtab %}
{% endtabs %}

## 2.3.2 Two’s-Complement Addition

With two’s-complement addition, we must decide what to do when the result is either too large (positive) or too small (negative) to represent. Given integer values x and y in the range −2^{w−1} ≤ x, y ≤ 2^{w−1} − 1, their sum is in the range −2^w ≤ x + y ≤ 2^w − 2, potentially requiring w + 1 bits to represent exactly. As before, we avoid ever-expanding data sizes by truncating the representation to w bits. The result is not as familiar mathematically as modular addition, however. Let us define x $$+^t_w$$ y to be the result of truncating the integer sum x + y to be w bits long and then viewing the result as a two’s-complement number.

![](<../../.gitbook/assets/image (27).png>)

This principle is illustrated in Figure 2.24, where the sum x + y is shown on the left, having a value in the range −2^w ≤ x + y ≤ 2^w − 2, and the result of truncating the sum to a w-bit two’s-complement number is shown on the right. (The labels “Case 1” to “Case 4” in this figure are for the case analysis of the formal derivation of the principle.) When the sum x + y exceeds $$TMax_w$$ (case 4), we say that **positive overflow** has occurred. In this case, the effect of truncation is to subtract 2^w from the sum. When the sum x + y is less than $$TMin_w$$ (case 1), we say that **negative overflow** has occurred. In this case, the effect of truncation is to add 2^w to the sum.

![Figure 2.24
Relation between integer and two’s-complement addition. When x + y is less than −2^{w−1}, there is a negative overflow. When it is greater than or equal to 2^{w−1}, there is a positive overflow.](<../../.gitbook/assets/image (26).png>)

The w-bit two’s-complement sum of two numbers has the exact same bit-level representation as the unsigned sum. In fact, most computers use the same machine instruction to perform either unsigned or signed addition.

<mark style="color:blue;">**DERIVATION**</mark>**: Two’s-complement addition**

Since two’s-complement addition has the exact same bit-level representation as unsigned addition, we can characterize the operation $$+^t_w$$ as one of converting its arguments to unsigned, performing unsigned addition, and then converting back to two’s complement:

![](<../../.gitbook/assets/image (30).png>)

![](<../../.gitbook/assets/image (13).png>)

As illustrations of two’s-complement addition, Figure 2.25 shows some examples when w = 4. Each example is labeled by the case to which it corresponds in the derivation of Equation 2.13. Note that 2^4 = 16, and hence negative overflow yields a result 16 more than the integer sum, and positive overflow yields a result 16 less. We include bit-level representations of the operands and the result. Observe that the result can be obtained by performing binary addition of the operands and truncating the result to 4 bits.

![Figure 2.25
Two’s-complement addition examples. The bit-level representation of the 4-bit two’s-complement sum can be obtained by performing binary addition of the operands and truncating the result to 4 bits.](<../../.gitbook/assets/image (28).png>)

Figure 2.26 illustrates two’s-complement addition for word size w = 4. The operands range between −8 and 7. When x + y < −8, two’s-complement addition has a negative overflow, causing the sum to be incremented by 16. When −8 ≤ x + y < 8, the addition yields x + y. When x + y ≥ 8, the addition has a positive overflow, causing the sum to be decremented by 16. Each of these three ranges forms a sloping plane in the figure.

![Figure 2.26
Two’s-complement addition.
With a 4-bit word size, addition can have a negative overflow when x + y < −8 and a positive overflow when x + y ≥ 8.](<../../.gitbook/assets/image (18).png>)

Equation 2.13 also lets us identify the cases where overflow has occurred:

![](<../../.gitbook/assets/image (19).png>)

Figure 2.25 shows several illustrations of this principle for w = 4. The first entry shows a case of negative overflow, where two negative numbers sum to a positive one. The final entry shows a case of positive overflow, where two positive numbers sum to a negative one.

<mark style="color:blue;">**DERIVATION**</mark>**: Detecting overflow of two’s-complement addition**

Let us first do the analysis for positive overflow. If both x > 0 and y > 0 but s ≤ 0, then clearly positive overflow has occurred. Conversely, positive overflow requires (1) that x > 0 and y > 0 (otherwise, x + y < TMax\_w) and (2) that s ≤ 0 (from Equation 2.13). A similar set of arguments holds for negative overflow.

{% tabs %}
{% tab title="PP 2.29" %}
Fill in the following table in the style of Figure 2.25. Give the integer values of the 5-bit arguments, the values of both their integer and two’s-complement sums, the bit-level representation of the two’s-complement sum, and the case from the derivation of Equation 2.13.

| x     | y     | x+y | x+^t\_5y | Case |
| ----- | ----- | --- | -------- | ---- |
|       |       |     |          |      |
| 10100 | 10001 |     |          |      |
|       |       |     |          |      |
| 11000 | 11000 |     |          |      |
|       |       |     |          |      |
| 10111 | 01000 |     |          |      |
|       |       |     |          |      |
| 00010 | 00101 |     |          |      |
|       |       |     |          |      |
| 01100 | 00100 |     |          |      |
{% endtab %}

{% tab title="PP 2.30" %}
Write a function with the following prototype:

```c
/* Determine whether arguments can be added without overflow */
int tadd_ok(int x, int y);
```

This function should return 1 if arguments x and y can be added without causing overflow.
{% endtab %}

{% tab title="PP 2.31" %}
Your coworker gets impatient with your analysis of the overflow conditions for two’s-complement addition and presents you with the following implementation of `tadd_ok`:

```c
/* Determine whether arguments can be added without overflow */
/* WARNING: This code is buggy. */
int tadd_ok(int x, int y) {
    int sum = x+y;
    return (sum-x == y) && (sum-y == x);
}
```

You look at the code and laugh. Explain why.
{% endtab %}

{% tab title="PP 2.32" %}
You are assigned the task of writing code for a function `tsub_ok`, with arguments x and y, that will return 1 if computing x-y does not cause overflow. Having just written the code for Problem 2.30, you write the following:

```c
/* Determine whether arguments can be subtracted without overflow */
/* WARNING: This code is buggy. */
int tsub_ok(int x, int y) {
    return tadd_ok(x, -y);
}
```

For what values of x and y will this function give incorrect results? Writing a correct version of this function is left as an exercise (Problem 2.74).
{% endtab %}
{% endtabs %}

{% tabs %}
{% tab title="S 2.29" %}
| x     | y     | x+y    | x+^t\_5y | Case |
| ----- | ----- | ------ | -------- | ---- |
| -12   | -15   | -27    | 5        | 1    |
| 10100 | 10001 | 100101 | 00101    |      |
| -8    | -8    | -16    | 8        | 1    |
| 11000 | 11000 | 110000 | 10000    |      |
| -9    | 8     | -1     | -1       | 2    |
| 10111 | 01000 | 111111 | 11111    |      |
| 2     | 5     | 7      | 7        | 3    |
| 00010 | 00101 | 000111 | 00111    |      |
| 12    | 4     | 16     | -16      | 4    |
| 01100 | 00100 | 10000  | 10000    |      |


{% endtab %}

{% tab title="S 2.30" %}
```c
/* Determine whether arguments can be added without overflow */
int tadd_ok(int x, int y) {
    return !((x>0 && y>0 && x+y<=0) ||
             (x<0 && y<0 && x+y>=0));
}
```
{% endtab %}

{% tab title="S 2.31" %}
if x = TMin or y = TMin, will cause -x or -y overflow.
{% endtab %}

{% tab title="S 2.32" %}
When y = TMin,  -y will overflow.

\-y also equal to TMin, cause this function give incorrect results.

```c
/* Determine whether arguments can be subtracted without overflow */
int tsub_ok(int x, int y) {
    if (y == INTMIN)
        return 0;
    else
        return tadd_ok(x, -y);
}
```
{% endtab %}
{% endtabs %}

## 2.3.3 Two’s-Complement Negation

## 2.3.4 Unsigned Multiplication

## 2.3.5 Two’s-Complement Multiplication

## 2.3.6 Multiplying by Constants

## 2.3.7 Dividing by Powers of 2

## 2.3.8 Final Thoughts on Integer Arithmetic
