# 2.1 信息存储

大多数计算机使用 8 位的块，或者**字节**（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**（virtual memory）。内存的每个字节都由一个唯一的数字来标识，称为它的**地址**（address），所有可能地址的集合就称为**虚拟地址空间**（virtual address space）。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现（见第 9 章）是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

在接下来的几章中，我们将讲述编译器和运行时系统是如何将存储器空间划分为更可管理的单元，来存放不同的程序对象（program object），即程序数据、指令和控制信息。可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。例如，C 语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。C 编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管 C 编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

{% hint style="info" %}
#### 给 C 语言初学者 - C 语言中指针的作用

指针是 C 语言的一个重要特性。它提供了引用数据结构（包括数组）的元素的机制。与变量类似，指针也有两个方面：值和类型。它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的类型（比如整数或者浮点数）。

真正理解指针需要查看它们在机器级上的表示以及实现。这将是第 3 章的重点之 一，3.10.1 节将对其进行深入介绍。
{% endhint %}

## 2.1.1 十六进制表示法

一个字节由8位组成。在二进制表示法中，它的值域是 $$00000000_2$$\~$$11111111_2$$。如果看成十进制整数，它的值域就是$$0_{10}$$\~$$255_{10}$$。两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是，以 16 为基数，或者叫做_十六进制（hexadecimal）数_，来表示位模式。十六进制（简写为 "hex"） 使用数字 '0' \~ '9' 以及字符 'A' \~ 'F' 来表示 16 个可能的值。图 2-2 展示了 16 个十六进制数字对应的十进制值和二进制值。用十六进制书写，一个字节的值域为$$00_{16}$$\~$$FF_{16}$$。

![Figure 2.2 Hexadecimal notation. Each hex digit encodes one of 16 values.](<../../.gitbook/assets/image (1) (1).png>)

在 C 语言中，以 0x 或 0X 开头的数字常量被认为是十六进制的值。字符 ‘A' \~ ‘F’ 既可以是大写，也可以是小写。例如，我们可以将数字 FA1D37B16 写作 0xFA1D37B，或者 0xfald37b，甚至是大小写混合，比如，0XFa1D37b。在本书中，我们将使用 C 表示法来表示十六进制值。&#x20;

编写机器级程序的一个常见任务就是在位模式的十进制、二进制和十六进制表示之间人工转换。二进制和十六进制之间的转换比较简单直接，因为可以一次执行一个十六进制数字的转换。数字的转换可以参考如图 2-2 所示的表。<mark style="color:green;">一个简单的窍门是，记住十六进制数字 A、C 和 F 相应的十进制值。而对于把十六进制值 B、D 和 E 转换成十进制值，则可以通过计算它们与前三个值的相对关系来完成。</mark>

比如，假设给你一个数字 0x173A4C。可以通过展开每个十六进制数字，将它转换为二进制格式，如下所示：

![0x173A4C to binary](<../../.gitbook/assets/image (1).png>)

这样就得到了二进制表示 000101110011101001001100。&#x20;

反过来，如果给定一个二进制数字1111001010110110110011，可以通过首先把它分为每 4 位一组来转换为十六进制。不过要注意，如果位总数不是 4 的倍数，最左边的一组可以少于 4 位，前面用 0 补足。然后将每个 4 位组转换为相应的十六进制数字：

![1111001010110110110011 to hexadecimal](<../../.gitbook/assets/image (2).png>)

当值 x 是 2 的非负整数 n 次幂时，也就是 $$x=2^n$$，我们可以很容易地将 x 写成十六进制形式，只要记住x 的二进制表示就是 1 后面跟 n 个 0。十六进制数字 0 代表 4 个二进制 0。所以，当 n 表示成 i+4j 的形式，其中 0≤i≤3，我们可以把 x 写成开头的十六进制数字为 1(i=0)、2(i=1)、4(i=2) 或者8(i=3)，后面跟随着 i 个十六进制的 0。比如, $$x=2048=2^{11}$$，我们有 n=11=3+4×2，从而得到十六进制表示 0x800。

{% tabs %}
{% tab title="Practice Problem 2.1" %}
Perform the following number conversions:&#x20;



A. 0x25B9D2 to binary&#x20;

B. binary 1010111001001001 to hexadecimal&#x20;

C. 0xA8B3D to binary&#x20;

D. binary 1100100010110110010110 to hexadecimal
{% endtab %}

{% tab title="Practice Problem 2.2" %}
Fill in the blank entries in the following table, giving the decimal and hexadecimal representations of different powers of 2:

|  n  | 2^n (十进制) | 2^n (十六进制) |
| :-: | :-------: | :--------: |
|  9  |    512    |    0x200   |
|  19 |           |            |
|     |   16384   |            |
|     |           |   0x10000  |
|  17 |           |            |
|     |     32    |            |
|     |           |    0x80    |
{% endtab %}
{% endtabs %}

{% tabs %}
{% tab title="Solution 2.1" %}
A. 0010 1001 1011 1001 1101 0010

B. AE69

C. 1010 1000 1011 0011 1101

D. 322D96
{% endtab %}

{% tab title="Solution 2.2" %}
|  n  | 2^n (十进制) | 2^n (十六进制) |
| :-: | :-------: | :--------: |
|  9  |    512    |    0x200   |
|  19 |   524288  |   0x80000  |
|  14 |   16384   |   0x4000   |
|  16 |   65536   |   0x10000  |
|  17 |   131072  |   0x20000  |
|  5  |     32    |    0x20    |
|  7  |    128    |    0x80    |
{% endtab %}
{% endtabs %}

十进制和十六进制表示之间的转换需要使用乘法或者除法来处理一般情况。将一个十进制数字 x 转换为十六进制，可以反复地用 16 除 x，得到一个商 q 和一个余数 r，也就是 x=q·16+r。然后，我们用十六进制数字表示的 r 作为最低位数字，并且通过对 q 反复进行这个过程得到剩下的数字。例如，考虑十进制 314156的转换：

![](<../../.gitbook/assets/image (4).png>)

从这里，我们能读出十六进制表示为 0x4CB2C。&#x20;

反过来，将一个十六进制数字转换为十进制数字，我们可以用相应的 16 的幂乘以每个十六进制数字。比如，给定数字 0x7AF，我们计算它对应的十进制值为 7·16^2+10· 16+15=7·256+10·16+15=1792+160+15=1967。

{% tabs %}
{% tab title="Practice Problem 2.3" %}
A single byte can be represented by 2 hexadecimal digits. \
Fill in the missing entries in the following table, giving the decimal, binary, and hexadecimal values of different byte patterns:

| 十进制 |    二进制    | 十六进制 |
| :-: | :-------: | :--: |
|  0  | 0000 0000 | 0x00 |
| 167 |           |      |
|  62 |           |      |
| 188 |           |      |
|     | 0011 0111 |      |
|     | 1000 1000 |      |
|     | 1111 0011 |      |
|     |           | 0x52 |
|     |           | 0xAC |
|     |           | 0xE7 |
{% endtab %}

{% tab title="Practice Problem 2.4" %}
Without converting the numbers to decimal or binary, try to solve the following arithmetic problems, giving the answers in hexadecimal. \
_Hint: Just modify the methods you use for performing decimal addition and subtraction to use base 16._

A. 0x605c + 0x5 =&#x20;

B. 0x605c − 0x20 =&#x20;

C. 0x605c + 32 =&#x20;

D. 0x60fa − 0x605c =
{% endtab %}
{% endtabs %}

{% tabs %}
{% tab title="Solution 2.3" %}
| 十进制 |    二进制    | 十六进制 |
| :-: | :-------: | :--: |
|  0  | 0000 0000 | 0x00 |
| 167 | 1010 0111 | 0xA7 |
|  62 | 0011 1110 | 0x3E |
| 188 | 1011 1100 | 0xBC |
|  55 | 0011 0111 | 0x37 |
| 136 | 1000 1000 | 0x88 |
| 243 | 1111 0011 | 0xF3 |
|  82 | 0101 0010 | 0x52 |
| 172 | 1010 1100 | 0xAC |
| 231 | 1110 0111 | 0xE7 |
{% endtab %}

{% tab title="Solution 2.4" %}
A. 0x605c + 0x5 = 0x6061

B. 0x605c − 0x20 = 0x603c

C. 0x605c + 32 = 0x607c

D. 0x60fa − 0x605c =0x9e
{% endtab %}
{% endtabs %}

{% hint style="info" %}
#### 十进制和十六进制间的转换&#x20;

较大数值的十进制和十六进制之间的转换，最好是让计算机或者计算器来完成。有大量的工具可以完成这个工作。\
一个简单的方法就是利用任何标准的搜索引擎，比如查询：&#x20;

Convert 0xabcd to decimal

or

123 in hex
{% endhint %}

## 2.1.2 字数据大小

每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 w 位的机器而言，虚拟地址的范围为 0\~$$2^w$$-1，程序最多访问个 $$2^w$$ 字节。&#x20;

最近这些年，出现了大规模的从 32 位字长机器到 64 位字长机器的迁移。这种情况首先出现在为大型科学和数据库应用设计的高端机器上，之后是台式机和笔记本电脑，最近则出现在智能手机的处理器上。32 位字长限制虚拟地址空间为 4 千兆字节（写作 4GB），也就是说，刚刚超过 4×$$10^9$$ 字节。扩展到 64 位字长使得虚拟地址空间为 16EB，大约是 1.84×$$10^{19}$$ 字节。

> 1EB = 1024PB
>
> 1PB=1024TB
>
> 1TB = 1024GB
>
> 1GB = 1024MB
>
> 1MB = 1024KB
>
> 1KB = 1024B

大多数 64 位机器也可以运行为 32 位机器编译的程序，这是一种向后兼容。因此，举例来说，当程序`prog.c` 用如下伪指令编译后:

```shell
gcc -m32 prog.c
```

该程序就可以在 32 位或 64 位机器上正确运行。另一方面，若程序用下述伪指令编译:

```
gcc -m64 prog.c
```

那就只能在 64 位机器上运行。<mark style="color:green;">因此，我们将程序称为 “32 位程序” 或 “64 位程序” 时，区别在于该程序是如何编译的，而不是其运行的机器类型。</mark>&#x20;

计算机和编译器支持多种不同方式编码的数字格式，如不同长度的整数和浮点数。比如，许多机器都有处理单个字节的指令，也有处理表示为 2 字节、4 字节或者 8 字节整数的指令，还有些指令支持表示为 4 字节和 8 字节的浮点数。

C 语言支持整数和浮点数的多种数据格式。图2-3展示了为 C 语言各种数据类型分配的字节数。（我们将在 2.2 节讨论 C 标准保证的字节数和典型的字节数之间的关系。）有些数据类型的确切字节数依赖于程序是如何被编译的。我们给出的是 32 位和 64 位程序的典型值。整数或者为有符号的，即可以表示负数、零和正数；或者为无符号的，即只能表示非负数。C 的数据类型 char 表示一个单独的字节。尽管 “char” 是由于它被用来存储文本串中的单个字符这一事实而得名，但它也能被用来存储整数值。数据类型 short、int 和 long 可以提供各种数据大小。即使是为 64 位系统编译，数据类型 int 通常也只有 4 个字节。数据类型 long 一般在 32 位程序中为 4 字节，在 64 位程序中则为 8 字节。

![Figure 2.3 Typical sizes (in bytes) of basic C data types. The number of bytes allocated varies with how the program is compiled. This chart shows the values typical of 32-bit and 64-bit programs.](../../.gitbook/assets/image.png)

为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 `int32t` 和 `int64t`，它们分别为 4 个字节和 8 个字节。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。&#x20;

大部分数据类型都编码为有符号数值，除非有前缀关键字 unsigned 或对确定大小的数据类型使用了特定的无符号声明。<mark style="color:green;">数据类型 char 是一个例外。尽管大多数编译器和机器将它们视为有符号数，但 C 标准不保证这一点。相反，正如方括号指示的那样，程序员应该用有符号字符的声明来保证其为一个字节的有符号数值。</mark>不过，在很多情况下，程序行为对数据类型 char 是有符号的还是无符号的并不敏感。&#x20;

对关键字的顺序以及包括还是省略可选关键字来说，C 语言允许存在多种形式。比如，下面所有的声明都是一个意思：

unsigned long&#x20;

unsigned long int&#x20;

long unsigned&#x20;

long unsigned int

我们将始终使用图 2-3 给出的格式。 图 2-3 还展示了指针（例如一个被声明为类型为 `char*` 的变量）使用程序的全字长。大多数机器还支持两种不同的浮点数格式：单精度（在  C 中声明为 `float`）和双精度（在 C 中声明为 `double`）。这些格式分别使用 4 字节和 8 字节。

{% hint style="info" %}
#### 给C语言初学者 --- 声明指针

对于任何数据类型 T，声明&#x20;

T \*p;

表明 p 是一个指针变量，指向一个类型为 T 的对象。例如:

char \*p;

就将一个指针声明为指向一个 char 类型的对象。
{% endhint %}

程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。C 语言标准对不同数据类型的数字范围设置了下界（这点在后面还将讲到），但是却没有上界。因为从 1980 年左右到 2010 年左右，3 2位机器和 32 位程序是主流的组合，许多程序的编写都假设为图 2-3 中 32 位程序的字节分配。随着 64 位机器的日益普及，在将这些程序移植到新机器上时，许多隐藏的对字长的依赖性就会显现出来，成为错误。<mark style="color:green;">比如，许多程序员假设一个声明为</mark> <mark style="color:green;"></mark><mark style="color:green;">`int`</mark> <mark style="color:green;"></mark><mark style="color:green;">类型的程序对象能被用来存储一个指针。这在大多数 32 位的机器上能正常工作，但是在一台 64 位的机器上却会导致问题。</mark>

## 2.1.3 寻址和字节顺序

大端法

| \*\*\*\* | 0x100 | 0x101 | 0x102 | 0x103 |     |
| -------- | :---: | :---: | :---: | :---: | :-: |
| ⋯        |   01  |   23  |   45  |   67  |  ⋯  |

小端法

| \*\*\*\* | 0x100 | 0x101 | 0x102 | 0x103 |     |
| -------- | :---: | :---: | :---: | :---: | :-: |
| ⋯        |   67  |   45  |   23  |   01  |  ⋯  |

## 2.1.4 表示字符串

## 2.1.5 表示代码

## 2.1.6 布尔代数简介

## 2.1.7 C 语言中的位级运算

## 2.1.8 C 语言中的逻辑运算

## 2.1.9 C 语言中的移位运算
