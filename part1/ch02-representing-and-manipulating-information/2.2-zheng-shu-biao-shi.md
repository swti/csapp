# 2.2 Integer Representations

In this section, we describe two different ways bits can be used to encode integers — one that can only represent nonnegative numbers, and one that can represent negative, zero, and positive numbers. We will see later that they are strongly related both in their mathematical properties and their machine-level implementations. We also investigate the effect of expanding or shrinking an encoded integer to fit a representation with a different length.

Figure 2.8 lists the mathematical terminology we introduce to precisely define and characterize how computers encode and operate on integer data. This terminology will be introduced over the course of the presentation. The figure is included here as a reference.

![Figure 2.8 Terminology for integer data and arithmetic operations. The subscript w denotes the number of bits in the data representation.](<../../.gitbook/assets/image (13).png>)

## 2.2.1 Integral Data Types

C supports a variety of integral data types — ones that represent finite ranges of integers. These are shown in Figures 2.9 and 2.10, along with the ranges of values they can have for “typical” 32- and 64-bit programs. Each type can specify a size with keyword `char`, `short`, `long`, as well as an indication of whether the represented numbers are all nonnegative (declared as unsigned), or possibly negative (the default.) As we saw in Figure 2.3, the number of bytes allocated for the different sizes varies according to whether the program is compiled for 32 or 64 bits. Based on the byte allocations, the different sizes allow different ranges of values to be represented. The only machine-dependent range indicated is for size designator long. Most 64-bit programs use an 8-byte representation, giving a much wider range of values than the 4-byte representation used with 32-bit programs.

![Figure 2.9 Typical ranges for C integral data types for 32-bit programs.](<../../.gitbook/assets/image (7).png>)

![Figure 2.10 Typical ranges for C integral data types for 64-bit programs.](<../../.gitbook/assets/image (17).png>)

One important feature to note in Figures 2.9 and 2.10 is that the ranges are not symmetric—the range of negative numbers extends one further than the range of positive numbers. We will see why this happens when we consider how negative numbers are represented.

The C standards define minimum ranges of values that each data type must be able to represent. As shown in Figure 2.11, their ranges are the same or smaller than the typical implementations shown in Figures 2.9 and 2.10. In particular, with the exception of the fixed-size data types, we see that they require only a symmetric range of positive and negative numbers. We also see that data type `int` could be implemented with 2-byte numbers, although this is mostly a throwback to the days of 16-bit machines. We also see that size `long` can be implemented with 4-byte numbers, and it typically is for 32-bit programs. The fixed-size data types guarantee that the ranges of values will be exactly those given by the typical numbers of Figure 2.9, including the asymmetry between negative and positive.

![Figure 2.11 Guaranteed ranges for C integral data types. The C standards require that the data types have at least these ranges of values.](<../../.gitbook/assets/image (20).png>)

{% hint style="info" %}
#### New to C? --- Signed and unsigned numbers in C, C++, and Java

Both C and C++ support signed (the default) and unsigned numbers. Java supports only signed numbers.
{% endhint %}

## 2.2.2 Unsigned Encodings

Let us consider an integer data type of w bits. We write a bit vector as either <img src="../../.gitbook/assets/image (9).png" alt="" data-size="line">, to denote the entire vector, or as \[$$x_{w-1}$$, $$x_{w-2}$$, ..., $$x_0$$] to denote the individual bits within the vector. Treating x as a number written in binary notation, we obtain the unsigned interpretation of x . In this encoding, each bit $$x_i$$ has value 0 or 1, with the latter case indicating that value $$2^i$$ should be included as part of the numeric value. We can express this interpretation as a function $$B2U_w$$ (for “binary to unsigned,” length w):

![](<../../.gitbook/assets/image (1).png>)

In this equation, the notation <img src="../../.gitbook/assets/image (4).png" alt="" data-size="line"> means that the left-hand side is defined to be equal to the right-hand side. The function $$B2U_w$$ maps strings of zeros and ones of length w to nonnegative integers. As examples, Figure 2.12 shows the mapping, given by B2U, from bit vectors to integers for the following cases:

![](<../../.gitbook/assets/image (15).png>)

In the figure, we represent each bit position i by a rightward-pointing blue bar of length $$2^i$$. The numeric value associated with a bit vector then equals the sum of the lengths of the bars for which the corresponding bit values are 1.

![Figure 2.12 Unsigned number examples for w = 4. When bit i in the binary representation has value 1, it contributes 2i to the value.](<../../.gitbook/assets/image (18).png>)

Let us consider the range of values that can be represented using w bits. The least value is given by bit vector \[00 ... 0] having integer value 0, and the greatest value is given by bit vector \[11 ... 1] having integer value <img src="../../.gitbook/assets/image (11).png" alt="" data-size="original"> = 2w − 1. Using the 4-bit case as an example, we have $$UMax_4$$ = $$B2U_4$$(\[1111]) = $$2^4$$ − 1= 15. Thus, the function $$B2U_w$$ can be defined as a mapping $$B2U_w$$:$$\{0, 1\}^w$$ → {0, ..., $$UMax_w$$}.

The unsigned binary representation has the important property that every number between 0 and $$2^w$$ − 1 has a unique encoding as a w-bit value. For example, there is only one representation of decimal value 11 as an unsigned 4-bit number— namely, \[1011]. We highlight this as a mathematical principle, which we first state and then explain.

![](<../../.gitbook/assets/image (10).png>)

The mathematical term **bijection** refers to a function f that goes two ways: it maps a value x to a value y where y = f (x), but it can also operate in reverse, since for every y, there is a unique value x such that f (x) = y. This is given by the inverse function $$f^{−1}$$, where, for our example, x = $$f^{-1}$$(y). The function $$B2U_w$$ maps each bit vector of length w to a unique number between 0 and $$2^w$$ − 1, and it has an inverse, which we call $$U2B_w$$ (for “unsigned to binary”), that maps each number in the range 0 to $$2^w$$ − 1 to a unique pattern of w bits.
